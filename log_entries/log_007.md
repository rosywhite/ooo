###### [back](./../README.md)

### Log #7 - rust book ch.3
##### Date: jan 4, 2022
-----------
Here's a [link](https://doc.rust-lang.org/book/) to the Rust Book. :)

Functions

- `main` `fn` `a_function();`
- Rust doesn’t care where you define your functions, only that they’re defined somewhere. e.g. after the main function in the source code
- Functions can also be defined to have parameters
- When a function has parameters, you can provide it with concrete values for those parameters
- Technically, the concrete values are called arguments, but in casual conversation, people tend to use the words parameter and argument interchangeably for either the variables in a function’s definition or the concrete values passed in when you call a function.
- In function signatures, you must declare the type of each parameter.
- requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what type you mean


- Function bodies are made up of a series of statements optionally ending in an expression
- So far, we’ve only covered functions without an ending expression, but you have seen an expression as part of a statement.
- Rust is an expression-based language, this is an important distinction to understand
- Statements are instructions that perform some action and do not return a value. 
- Expressions evaluate to a resulting value.
- Consider a math operation, such as 5 + 6, which is an expression that evaluates to the value 11
-  the 6 in the statement let y = 6; is an expression that evaluates to the value 6
- Calling a function is an expression. Calling a macro is an expression
- Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.


- Functions can return values to the code that calls them. We don’t name return values, but we do declare their type after an arrow (->)
- The main error message, “mismatched types,” reveals the core issue with this code. The definition of the function plus_one says that it will return an i32, but statements don’t evaluate to a value, which is expressed by (), the unit type. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.

###### [back](./../README.md)****